@using MediChatAI_BlazorWebAssembly.Features.Patient.DTOs
@using Microsoft.AspNetCore.Components.Authorization
@inject AuthenticationStateProvider AuthStateProvider

<div class="in-call-chat h-full flex flex-col bg-gray-850">

    <!-- Chat Header -->
    <div class="chat-header bg-gray-800 border-b border-gray-700 px-4 py-3 flex items-center justify-between">
        <div class="flex items-center space-x-2">
            <svg class="w-5 h-5 text-primary-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 12h.01M12 12h.01M16 12h.01M21 12c0 4.418-4.03 8-9 8a9.863 9.863 0 01-4.255-.949L3 20l1.395-3.72C3.512 15.042 3 13.574 3 12c0-4.418 4.03-8 9-8s9 3.582 9 8z"></path>
            </svg>
            <h3 class="text-white font-semibold text-sm">In-Call Chat</h3>
        </div>
        @if (unreadCount > 0 && !isVisible)
        {
            <span class="badge badge-sm bg-red-500 text-white">@unreadCount</span>
        }
    </div>

    <!-- Messages Container -->
    <div class="messages-container flex-1 overflow-y-auto p-4 space-y-3" @ref="messagesContainer">
        @if (!messages.Any())
        {
            <div class="text-center py-8">
                <svg class="w-12 h-12 text-gray-600 mx-auto mb-3" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 12h.01M12 12h.01M16 12h.01M21 12c0 4.418-4.03 8-9 8a9.863 9.863 0 01-4.255-.949L3 20l1.395-3.72C3.512 15.042 3 13.574 3 12c0-4.418 4.03-8 9-8s9 3.582 9 8z"></path>
                </svg>
                <p class="text-gray-500 text-sm">No messages yet</p>
                <p class="text-gray-600 text-xs mt-1">Start a conversation</p>
            </div>
        }
        else
        {
            @foreach (var message in messages)
            {
                <div class="@GetMessageClass(message.IsSender)">
                    <div class="message-bubble @GetBubbleClass(message.IsSender)">
                        <!-- Message Content -->
                        <div class="message-content">
                            <p class="text-sm whitespace-pre-wrap break-words">@message.Content</p>
                        </div>

                        <!-- Message Footer -->
                        <div class="message-footer flex items-center justify-between mt-1 text-xs opacity-70">
                            <span class="message-time">@FormatTime(message.SentAt)</span>
                            @if (message.IsSender)
                            {
                                @if (message.ReadAt.HasValue)
                                {
                                    <svg class="w-4 h-4 text-blue-400" fill="currentColor" viewBox="0 0 20 20">
                                        <path d="M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z"></path>
                                    </svg>
                                }
                                else
                                {
                                    <svg class="w-4 h-4" fill="currentColor" viewBox="0 0 20 20">
                                        <path d="M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z"></path>
                                    </svg>
                                }
                            }
                        </div>

                        <!-- Reactions -->
                        @if (message.Reactions?.Any() == true)
                        {
                            <div class="message-reactions flex flex-wrap gap-1 mt-2">
                                @foreach (var reaction in message.Reactions)
                                {
                                    <button @onclick="() => RemoveReaction(message.Id, reaction.Emoji)"
                                            class="reaction-badge px-2 py-1 bg-gray-700 hover:bg-gray-600 rounded-full text-xs flex items-center space-x-1 transition-colors">
                                        <span>@reaction.Emoji</span>
                                        <span class="text-gray-400">@reaction.Count</span>
                                    </button>
                                }
                            </div>
                        }
                    </div>

                    <!-- Quick Reactions -->
                    @if (!message.IsSender && showReactionMenuFor != message.Id)
                    {
                        <button @onclick="() => showReactionMenuFor = message.Id"
                                class="reaction-trigger ml-2 opacity-0 group-hover:opacity-100 transition-opacity">
                            <svg class="w-4 h-4 text-gray-400 hover:text-gray-300" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M14.828 14.828a4 4 0 01-5.656 0M9 10h.01M15 10h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
                            </svg>
                        </button>
                    }

                    <!-- Reaction Menu -->
                    @if (showReactionMenuFor == message.Id)
                    {
                        <div class="reaction-menu flex space-x-1 ml-2 bg-gray-700 rounded-lg px-2 py-1">
                            @foreach (var emoji in quickReactions)
                            {
                                <button @onclick="() => AddReaction(message.Id, emoji)"
                                        class="hover:scale-125 transition-transform text-lg">
                                    @emoji
                                </button>
                            }
                            <button @onclick="() => showReactionMenuFor = Guid.Empty"
                                    class="text-gray-400 hover:text-white ml-1">
                                <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                                </svg>
                            </button>
                        </div>
                    }
                </div>
            }
        }

        <!-- Typing Indicator -->
        @if (isPartnerTyping)
        {
            <div class="flex items-start">
                <div class="typing-indicator bg-gray-700 rounded-2xl px-4 py-3">
                    <div class="flex space-x-1">
                        <div class="typing-dot w-2 h-2 bg-gray-400 rounded-full animate-bounce" style="animation-delay: 0ms"></div>
                        <div class="typing-dot w-2 h-2 bg-gray-400 rounded-full animate-bounce" style="animation-delay: 150ms"></div>
                        <div class="typing-dot w-2 h-2 bg-gray-400 rounded-full animate-bounce" style="animation-delay: 300ms"></div>
                    </div>
                </div>
            </div>
        }
    </div>

    <!-- Message Input -->
    <div class="message-input-container bg-gray-800 border-t border-gray-700 p-3">
        <div class="flex items-end space-x-2">
            <div class="flex-1">
                <textarea @bind="newMessage"
                          @bind:event="oninput"
                          @onkeydown="HandleKeyDown"
                          rows="1"
                          maxlength="1000"
                          placeholder="Type a message..."
                          class="w-full bg-gray-750 text-white rounded-lg px-3 py-2 text-sm resize-none focus:outline-none focus:ring-2 focus:ring-primary-500 placeholder-gray-500"
                          style="max-height: 120px; overflow-y: auto;"></textarea>
            </div>

            <!-- Send Button -->
            <button @onclick="SendMessage"
                    disabled="@(string.IsNullOrWhiteSpace(newMessage) || isSending)"
                    class="btn btn-primary btn-sm flex-shrink-0">
                @if (isSending)
                {
                    <span class="loading loading-spinner loading-xs"></span>
                }
                else
                {
                    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 19l9 2-9-18-9 18 9-2zm0 0v-8"></path>
                    </svg>
                }
            </button>
        </div>

        <!-- Character Count -->
        @if (newMessage.Length > 900)
        {
            <div class="text-xs text-gray-500 mt-1 text-right">
                @newMessage.Length / 1000
            </div>
        }
    </div>

</div>

<style>
    .in-call-chat {
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
    }

    .message-bubble {
        position: relative;
        max-width: 85%;
        padding: 0.625rem 0.875rem;
        border-radius: 1rem;
        word-wrap: break-word;
        transition: all 0.2s ease;
    }

    .message-bubble:hover {
        transform: translateY(-1px);
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
    }

    .message-sent {
        background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%);
        color: white;
        border-bottom-right-radius: 0.25rem;
        margin-left: auto;
    }

    .message-received {
        background: #374151;
        color: #f3f4f6;
        border-bottom-left-radius: 0.25rem;
    }

    .messages-container::-webkit-scrollbar {
        width: 6px;
    }

    .messages-container::-webkit-scrollbar-track {
        background: #1f2937;
    }

    .messages-container::-webkit-scrollbar-thumb {
        background: #4b5563;
        border-radius: 3px;
    }

    .messages-container::-webkit-scrollbar-thumb:hover {
        background: #6b7280;
    }

    @@keyframes bounce {
        0%, 100% {
            transform: translateY(0);
        }
        50% {
            transform: translateY(-5px);
        }
    }

    .typing-dot {
        animation: bounce 1s infinite;
    }
</style>

@code {
    [Parameter]
    public string PartnerId { get; set; } = string.Empty;

    [Parameter]
    public string PartnerName { get; set; } = string.Empty;

    [Parameter]
    public EventCallback OnChatMinimized { get; set; }

    private ElementReference messagesContainer;
    private List<MessageDto> messages = new();
    private string newMessage = string.Empty;
    private string currentUserId = string.Empty;
    private bool isSending = false;
    private bool isVisible = true;
    private int unreadCount = 0;
    private bool isPartnerTyping = false;
    private Guid showReactionMenuFor = Guid.Empty;

    private readonly string[] quickReactions = new[] { "üëç", "‚ù§Ô∏è", "üòä", "üòÇ", "üëè", "üéâ" };

    protected override async Task OnInitializedAsync()
    {
        var authState = await AuthStateProvider.GetAuthenticationStateAsync();
        var user = authState.User;
        currentUserId = user.FindFirst(System.Security.Claims.ClaimTypes.NameIdentifier)?.Value ?? string.Empty;

        // TODO: Load existing messages from conversation
        // await LoadMessages();
    }

    protected override async Task OnParametersSetAsync()
    {
        if (!string.IsNullOrEmpty(PartnerId))
        {
            // TODO: Load conversation messages when PartnerId changes
            // await LoadMessages();
        }
        await Task.CompletedTask;
    }

    private Task LoadMessages()
    {
        // TODO: Implement message loading via GraphQL
        // This would call the messaging service to get conversation messages
        // For now, using placeholder
        messages = new List<MessageDto>();
        return Task.CompletedTask;
    }

    private async Task SendMessage()
    {
        if (string.IsNullOrWhiteSpace(newMessage) || isSending) return;

        isSending = true;
        try
        {
            // TODO: Implement message sending via GraphQL
            // var sentMessage = await MessageService.SendMessageAsync(PartnerId, newMessage);

            // Temporary: Add message to local list
            var message = new MessageDto
            {
                Id = Guid.NewGuid(),
                SenderId = currentUserId,
                ReceiverId = PartnerId,
                Content = newMessage.Trim(),
                SentAt = DateTime.UtcNow,
                IsSender = true,
                Status = "Sent"
            };

            messages.Add(message);
            newMessage = string.Empty;

            await ScrollToBottom();
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error sending message: {ex.Message}");
        }
        finally
        {
            isSending = false;
        }
    }

    private async Task HandleKeyDown(KeyboardEventArgs e)
    {
        if (e.Key == "Enter" && !e.ShiftKey)
        {
            await SendMessage();
        }

        // TODO: Send typing indicator
        // await MessageService.SendTypingIndicator(PartnerId);
        await Task.CompletedTask;
    }

    private void AddReaction(Guid messageId, string emoji)
    {
        try
        {
            // TODO: Implement reaction via GraphQL
            // await MessageService.AddReactionAsync(messageId, emoji);

            // Temporary: Update local message
            var message = messages.FirstOrDefault(m => m.Id == messageId);
            if (message != null)
            {
                var existingReaction = message.Reactions.FirstOrDefault(r => r.Emoji == emoji);
                if (existingReaction != null)
                {
                    existingReaction.Count++;
                }
                else
                {
                    message.Reactions.Add(new ReactionCountDto { Emoji = emoji, Count = 1 });
                }
            }

            showReactionMenuFor = Guid.Empty;
            StateHasChanged();
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error adding reaction: {ex.Message}");
        }
    }

    private void RemoveReaction(Guid messageId, string emoji)
    {
        try
        {
            // TODO: Implement reaction removal via GraphQL
            // await MessageService.RemoveReactionAsync(messageId, emoji);

            // Temporary: Update local message
            var message = messages.FirstOrDefault(m => m.Id == messageId);
            if (message != null)
            {
                var reaction = message.Reactions.FirstOrDefault(r => r.Emoji == emoji);
                if (reaction != null)
                {
                    if (reaction.Count > 1)
                    {
                        reaction.Count--;
                    }
                    else
                    {
                        message.Reactions.Remove(reaction);
                    }
                }
            }

            StateHasChanged();
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error removing reaction: {ex.Message}");
        }
    }

    private string GetMessageClass(bool isSender)
    {
        return isSender
            ? "flex justify-end items-start group"
            : "flex justify-start items-start group";
    }

    private string GetBubbleClass(bool isSender)
    {
        return isSender ? "message-sent" : "message-received";
    }

    private string FormatTime(DateTime dateTime)
    {
        var now = DateTime.UtcNow;
        var diff = now - dateTime;

        if (diff.TotalMinutes < 1)
            return "Just now";
        else if (diff.TotalMinutes < 60)
            return $"{(int)diff.TotalMinutes}m ago";
        else if (diff.TotalHours < 24)
            return dateTime.ToString("h:mm tt");
        else if (diff.TotalDays < 7)
            return dateTime.ToString("ddd h:mm tt");
        else
            return dateTime.ToString("MMM dd, h:mm tt");
    }

    private async Task ScrollToBottom()
    {
        // TODO: Implement JS interop to scroll to bottom
        // await JSRuntime.InvokeVoidAsync("scrollToBottom", messagesContainer);
        await Task.CompletedTask;
    }
}
